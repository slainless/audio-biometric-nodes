# Simple Audio Biometric System with ESP32

Built on top of PlatformIO and Uvicorn.

## Components

On microcontroller side, ESP32 are used to collect and send audio recording, and control the end peripheral.
The code is based on [Arduino ESP-IDF](https://docs.espressif.com/projects/arduino-esp32/en/latest/index.html).
INMP441 is used as recording peripheral.

The server itself is driven by Python. 
FastAPI and MQTT client, are running on Uvicorn lifecycle and will act as the server to process
the recording and send appropriate command or drop the invalid recording.

## Recording

The data generated by INMP441 is 24-bit left-justified MSB, so there is a bit preprocessing involved 
before building the WAV. Even before that, I2S must be setup to accomodate those bits per sample, 
so we are using 32 bits per sample in the configuration. 

Each sample needs to be shifted and then written to the buffer. The recording process is also not
that straightforward since the system is ran on top of bare ESP32 without PSRAM so it needs to write
to flash first before sending the audio.

## Audio Transmission

Since the audio is stored in flash, the upload process is also done in chunking fashion, 
reading and sending 512 bytes per transmission.

Some simple protocol is defined to allow this method of communication. 
So, the recorder will send chunks and the server will reassemble those chunks and do processing on it.
The server will obviously discard any partial or non-conforming packets.

## Audio Processing

For audio processing:
- Speechbrain model `speechbrain/spkrec-ecapa-voxceleb` to embed the audio
- OpenAI's Whisper model `base` to process transcription

## MQTT Payload Format

```
MSG_TYPE | 4B           | message type
ID_SIZE  | 1B           | identifier size (in bytes)
ID       | ${ID_SIZE}B  | identifier
PAYLOAD  | REMAINING    | payload
```

The remaining constraints can be seen at [protocol.h](./src/mqtt/protocol.h).

## Sequence Flow

```mermaid
sequenceDiagram
    actor User
    participant Lamp@{ "type": "entity" }
    participant Recorder
    participant Controller
    participant MQTT Broker
    participant Server

    User->>+Recorder: Recording
    Recorder->>-MQTT Broker: Audio
    MQTT Broker->>+Server: Audio

    critical Speaker verification
      Server->>Server: Calculating embedding
    option Not verified
      Server->>Server: Dropping message
    end

    critical Command verification
      Server->>Server: Matching command
    option Not matching
      Server->>Server: Dropping message
    end

    Server->>-MQTT Broker: Command
    MQTT Broker->>Controller: Command
    Controller->>+Lamp: ON/OFF
```

## Setup

It is recommended to start Mosquitto broker either by installing it as service
or using provided compose.

It is also recommended to use virtual environment. 
Run `python -m venv .venv`, then bootstrap the current terminal with venv.

After that, install python requirements by running `pip -r ./requirements`.

For the microcontrollers, flash the program using appropriate environment 
such as `recorder` for the recorder microcontroller 
and `controller` for the peripheral microcontroller.

## Quick Run

1. Start mosquitto MQTT broker server
2. Start server with `uvicorn src.server.main`
3. Setup wifi and mqtt for each microcontrollers using `wifi` and `mqtt` command respectively.
4. For mqtt configuration, use `localhost` or `ip.add.re.ss` of your mosquitto broker. 
   Then use port `1883` or other if using custom port.
5. Send `record` command to recorder serial port to start recording.
6. The server should receive the recording, verifying it, then send command to controller if successful.